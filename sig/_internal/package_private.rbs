module ActiveRecordCompose
  module Attributes
    extend ActiveSupport::Concern
    include ActiveModel::Attributes
    include Querying

    def self.delegate_attribute: (*untyped methods, to: untyped, ?allow_nil: bool) -> untyped
    def self.delegated_attributes: () -> Array[Delegation]
    def self.delegated_attributes=: (Array[Delegation]) -> untyped
    def delegated_attributes: () -> Array[Delegation]

    @attributes: untyped

    class AttributePredicate
      def initialize: (untyped value) -> void
      def call: -> bool

      @value: untyped

      private
      attr_reader value: untyped
    end

    class Delegation
      def initialize: (attribute: String, to: Symbol, ?allow_nil: bool) -> void
      def attribute: () -> Symbol
      def attribute_name: () -> String
      def attribute_hash: (Object model) -> Hash[String, untyped]
      def define_delegated_attribute: ((Module & ActiveModel::AttributeMethods::ClassMethods) klass) -> void

      @attribute: Symbol
      @to: Symbol
      @allow_nil: bool

      private
      def to: () -> Symbol
      def allow_nil: () -> bool
      def reader: () -> String
      def writer: () -> String
    end

    module Querying
      include ActiveModel::AttributeMethods
      extend ActiveSupport::Concern
      extend ActiveModel::AttributeMethods::ClassMethods

      private
      def attribute?: (attribute_name) -> untyped
      def query?: (untyped value) -> bool
    end
  end

  module Callbacks
    include ActiveModel::Model
    include ActiveModel::Validations::Callbacks
    extend ActiveSupport::Concern
    extend ActiveModel::Callbacks

    private
    def with_callbacks: { () -> bool } -> bool
    def callback_context: -> (:create | :update)
  end

  class ComposedCollection
    def initialize: (Model) -> void

    @symbol_proc_map: Hash[Symbol, (destroy_context_type | condition_type)]

    private
    attr_reader owner: Model
    attr_reader models: Set[WrappedModel]
    def wrap: (ar_like, ?destroy: (bool | Symbol | destroy_context_type), ?if: (nil | Symbol | condition_type)) -> WrappedModel
    def symbol_proc_map: () -> Hash[Symbol, (destroy_context_type | condition_type)]
    def instance_variables_to_inspect: () -> Array[Symbol]

    module PackagePrivate
      def __wrapped_models: () -> Enumerable[WrappedModel]

      private
      def models: () -> Set[WrappedModel]
    end

    include PackagePrivate
  end

  module Inspectable
    extend ActiveSupport::Concern
    include Attributes

    def self.inspection_filter: () -> ActiveSupport::ParameterFilter
    def self.filter_attributes: () -> Array[untyped]
    def self.filter_attributes=: (Array[untyped]) -> void
    def inspect: () -> String
    def pretty_print: (untyped q) -> void

    private
    def format_for_inspect: (String name, untyped value) -> String
  end

  class Model
    include Attributes
    include TransactionSupport
    include Callbacks

    @__models: ComposedCollection

    private
    def validate_models: -> void
    def override_validation_context: -> validation_context
  end

  module TransactionSupport
    extend ActiveSupport::Concern
    include ActiveRecord::Transactions
    include ActiveSupport::Callbacks
    extend ActiveSupport::Callbacks::ClassMethods

    def self.before_commit: (*untyped) -> untyped
    def self.after_commit: (*untyped) -> untyped
    def self.after_rollback: (*untyped) -> untyped

    def save: (**untyped options) -> bool
    def save!: (**untyped options) -> untyped
    def _run_before_commit_callbacks: () -> untyped
    def _run_commit_callbacks: () -> untyped
    def _run_rollback_callbacks: () -> untyped

    private
    def default_ar_class: -> singleton(ActiveRecord::Base)
    def connection_pool: (?ar_class: singleton(ActiveRecord::Base)) -> ActiveRecord::ConnectionAdapters::ConnectionPool
    def with_pool_transaction_isolation_level: [T] (ActiveRecord::ConnectionAdapters::AbstractAdapter) { () -> T } -> T
  end

  module Persistence
    include Callbacks
    include TransactionSupport

    def save: (**untyped options) -> bool
    def save!: (**untyped options) -> untyped
    def update: (Hash[attribute_name, untyped]) -> bool
    def update!: (Hash[attribute_name, untyped]) -> untyped

    private
    def models: -> ComposedCollection
    def save_models: (bang: bool, **untyped options) -> bool
    def raise_on_save_error: -> bot
    def raise_on_save_error_message: -> String
  end

  module Validations : Model
    extend ActiveSupport::Concern
    extend ActiveModel::Validations::ClassMethods

    def save: (**untyped options) -> bool
    def save!: (**untyped options) -> untyped
    def valid?: (?validation_context context) -> bool
    def detect_circular_reference: (?Array[Integer])-> untyped

    @context_for_override_validation: OverrideValidationContext

    private
    def perform_validations: (::Hash[untyped, untyped]) -> bool
    def raise_validation_error: -> bot
    def context_for_override_validation: -> OverrideValidationContext
    def override_validation_context: -> validation_context

    class OverrideValidationContext
      @context: validation_context

      attr_reader context: validation_context

      def with_override: [T] (validation_context) { () -> T } -> T
    end
  end

  class WrappedModel
    def initialize: (ar_like, ?destroy: (bool | destroy_context_type), ?if: (nil | condition_type)) -> void
    def destroy_context?: -> bool
    def ignore?: -> bool
    def save: (**untyped options) -> bool
    def save!: (**untyped options) -> untyped
    def invalid?: (?validation_context context) -> bool
    def valid?: (?validation_context context) -> bool
    def is_a?: (untyped) -> bool
    def ==: (untyped) -> bool

    private
    attr_reader model: ar_like
    attr_reader destroy_context_type: (bool | destroy_context_type)
    attr_reader if_option: (nil | condition_type)
    def equality_key: () -> [ar_like, (bool | destroy_context_type), (nil | condition_type)]

    module PackagePrivate
      def __raw_model: () -> ar_like

      private
      def model: () -> ar_like
    end

    include PackagePrivate
  end
end
