module ActiveRecordCompose
  module Callbacks
    include ActiveModel::Model
    include ActiveModel::Validations::Callbacks
    extend ActiveSupport::Concern
    extend ActiveModel::Callbacks

    private
    def with_callbacks: { () -> bool } -> bool
    def callback_context: -> (:create | :update)
  end

  class ComposedCollection
    def initialize: (Model) -> void

    private
    attr_reader owner: Model
    attr_reader models: Array[WrappedModel]
    def wrap: (ar_like, ?destroy: (bool | Symbol | destroy_context_type), ?if: (nil | Symbol | condition_type)) -> WrappedModel

    module PackagePrivate
      def __wrapped_models: () -> Array[WrappedModel]

      private
      def models: () -> Array[WrappedModel]
    end

    include PackagePrivate
  end

  module DelegateAttribute : ActiveModel::Attributes
    extend ActiveSupport::Concern

    def attributes: -> Hash[String, untyped]
    def delegated_attributes: () -> Array[String]

    module ClassMethods : Module
      def delegate_attribute: (*untyped methods, to: untyped, ?allow_nil: untyped?) -> untyped
      def delegated_attributes: () -> Array[String]
      def delegated_attributes=: (Array[String]) -> untyped
    end
  end

  class Model
    include DelegateAttribute
    extend DelegateAttribute::ClassMethods
    include TransactionSupport
    extend TransactionSupport::ClassMethods
    include ActiveRecordCompose::Callbacks

    @__models: ComposedCollection

    private
    def validate_models: -> void
    def override_validation_context: -> validation_context
  end

  module TransactionSupport
    include ActiveRecord::Transactions

    def id: -> untyped

    module ClassMethods
      def connection: -> ActiveRecord::ConnectionAdapters::AbstractAdapter
      def lease_connection: -> ActiveRecord::ConnectionAdapters::AbstractAdapter
      def with_connection: [T] () { () -> T } -> T

      private
      def ar_class: -> singleton(ActiveRecord::Base)
    end
  end

  module Validations : Model
    def save: (**untyped options) -> bool
    def save!: (**untyped options) -> untyped
    def valid?: (?validation_context context) -> bool

    @context_for_override_validation: OverrideValidationContext

    private

    def perform_validations: (::Hash[untyped, untyped]) -> bool
    def raise_validation_error: -> bot
    def context_for_override_validation: -> OverrideValidationContext
    def override_validation_context: -> validation_context

    class OverrideValidationContext
      @context: validation_context

      attr_reader context: validation_context

      def with_override: [T] (validation_context) { () -> T } -> T
    end
  end

  class WrappedModel
    def initialize: (ar_like, ?destroy: (bool | destroy_context_type), ?if: (nil | condition_type)) -> void
    def destroy_context?: -> bool
    def ignore?: -> bool
    def save: (**untyped options) -> bool
    def save!: (**untyped options) -> untyped
    def invalid?: (?validation_context context) -> bool
    def valid?: (?validation_context context) -> bool
    def is_a?: (untyped) -> bool
    def ==: (untyped) -> bool

    private
    attr_reader model: ar_like
    attr_reader destroy_context_type: (bool | destroy_context_type)
    attr_reader if_option: (nil | condition_type)

    module PackagePrivate
      def __raw_model: () -> ar_like

      private
      def model: () -> ar_like
    end

    include PackagePrivate
  end
end
